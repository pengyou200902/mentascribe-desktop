fn main() {
    tauri_build::build();

    #[cfg(feature = "voxtral")]
    build_voxtral();
}

#[cfg(feature = "voxtral")]
fn build_voxtral() {
    let voxtral_dir = std::path::Path::new("voxtral");
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let out_path = std::path::Path::new(&out_dir);

    // Core C source files (excluding main.c and inspect_weights.c)
    let c_sources = [
        "voxtral.c",
        "voxtral_audio.c",
        "voxtral_decoder.c",
        "voxtral_encoder.c",
        "voxtral_kernels.c",
        "voxtral_safetensors.c",
        "voxtral_tokenizer.c",
    ];

    let mut build = cc::Build::new();
    build
        .opt_level(3)
        .include(voxtral_dir);

    // Compiler-specific optimization flags
    let target_env = std::env::var("CARGO_CFG_TARGET_ENV").unwrap_or_default();
    if target_env == "msvc" {
        // MSVC equivalents
        build.flag("/fp:fast");
    } else {
        // GCC/Clang flags
        build.flag("-march=native");
        build.flag("-ffast-math");
        build.flag("-flto=thin");
    }

    for src in &c_sources {
        build.file(voxtral_dir.join(src));
    }

    let target_os = std::env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
    let target_arch = std::env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();

    if target_os == "macos" {
        // macOS: use Accelerate (BLAS) and optionally Metal on Apple Silicon
        build.flag("-DUSE_BLAS");
        println!("cargo:rustc-link-lib=framework=Accelerate");

        if target_arch == "aarch64" {
            // Apple Silicon: enable Metal GPU acceleration
            build.flag("-DUSE_METAL");

            // Generate voxtral_shaders_source.h — embeds the .metal shader as a C string
            // The voxtral_metal.m file includes this header to compile shaders at runtime
            generate_shader_header(voxtral_dir, out_path);

            // Precompile Metal shaders to .metallib at build time (~114ms init savings)
            generate_metallib_header(voxtral_dir, out_path);

            // Compile Objective-C Metal bridge
            let mut metal_build = cc::Build::new();
            metal_build
                .opt_level(3)
                .flag("-ffast-math")
                .flag("-flto=thin")
                .flag("-DUSE_METAL")
                .flag("-DUSE_PRECOMPILED_METALLIB")
                .include(voxtral_dir)
                .include(out_path) // For generated headers
                .file(voxtral_dir.join("voxtral_metal.m"));
            metal_build.compile("voxtral_metal");

            println!("cargo:rustc-link-lib=framework=Metal");
            println!("cargo:rustc-link-lib=framework=MetalPerformanceShaders");
            println!("cargo:rustc-link-lib=framework=Foundation");
            println!("cargo:rustc-link-lib=framework=CoreGraphics");
        }
    } else if target_os == "linux" {
        // Linux: use OpenBLAS
        build.flag("-DUSE_BLAS");
        println!("cargo:rustc-link-lib=openblas");
        println!("cargo:rustc-link-lib=m");
        println!("cargo:rustc-link-lib=pthread");
    } else if target_os == "windows" {
        // Windows: CPU-only fallback (no BLAS by default)
        // If OpenBLAS is installed, uncomment the following:
        // build.flag("-DUSE_BLAS");
        // println!("cargo:rustc-link-lib=openblas");
    }

    build.compile("voxtral");

    // Rerun if any voxtral source changes
    println!("cargo:rerun-if-changed=voxtral/");
}

/// Generate voxtral_shaders_source.h from voxtral_shaders.metal.
/// Embeds the Metal shader source as a byte array (xxd-style), matching
/// the variable names expected by voxtral_metal.m:
///   - `voxtral_shaders_metal` (unsigned char array)
///   - `voxtral_shaders_metal_len` (unsigned int)
#[cfg(feature = "voxtral")]
fn generate_shader_header(voxtral_dir: &std::path::Path, out_dir: &std::path::Path) {
    let shader_path = voxtral_dir.join("voxtral_shaders.metal");
    let header_path = out_dir.join("voxtral_shaders_source.h");

    let shader_bytes = std::fs::read(&shader_path)
        .expect("Failed to read voxtral_shaders.metal");

    let mut header = String::new();
    header.push_str("// Auto-generated by build.rs — do not edit\n");
    header.push_str("#ifndef VOXTRAL_SHADERS_SOURCE_H\n");
    header.push_str("#define VOXTRAL_SHADERS_SOURCE_H\n\n");
    header.push_str(&format!(
        "static const unsigned char voxtral_shaders_metal[] = {{\n"
    ));

    // Write bytes in rows of 16 (xxd style)
    for (i, byte) in shader_bytes.iter().enumerate() {
        if i % 16 == 0 {
            header.push_str("  ");
        }
        header.push_str(&format!("0x{:02x}", byte));
        if i + 1 < shader_bytes.len() {
            header.push_str(", ");
        }
        if i % 16 == 15 {
            header.push('\n');
        }
    }
    header.push_str("\n};\n\n");
    header.push_str(&format!(
        "static const unsigned int voxtral_shaders_metal_len = {};\n\n",
        shader_bytes.len()
    ));
    header.push_str("#endif // VOXTRAL_SHADERS_SOURCE_H\n");

    std::fs::write(&header_path, header)
        .expect("Failed to write voxtral_shaders_source.h");

    println!("cargo:rerun-if-changed={}", shader_path.display());
}

/// Precompile Metal shaders to .metallib at build time.
/// Embeds the binary as a C byte array in voxtral_metallib_source.h.
/// Saves ~114ms at init time by avoiding runtime shader compilation.
#[cfg(feature = "voxtral")]
fn generate_metallib_header(voxtral_dir: &std::path::Path, out_dir: &std::path::Path) {
    let shader_path = voxtral_dir.join("voxtral_shaders.metal");
    let air_path = out_dir.join("voxtral_shaders.air");
    let metallib_path = out_dir.join("voxtral_shaders.metallib");
    let header_path = out_dir.join("voxtral_metallib_source.h");

    // Compile .metal -> .air
    let status = std::process::Command::new("xcrun")
        .args([
            "-sdk", "macosx", "metal",
            "-c", shader_path.to_str().unwrap(),
            "-o", air_path.to_str().unwrap(),
        ])
        .status();

    match status {
        Ok(s) if s.success() => {}
        _ => {
            eprintln!("cargo:warning=Failed to compile .metal to .air, skipping metallib precompilation");
            write_empty_metallib_header(&header_path);
            return;
        }
    }

    // Link .air -> .metallib
    let status = std::process::Command::new("xcrun")
        .args([
            "-sdk", "macosx", "metallib",
            air_path.to_str().unwrap(),
            "-o", metallib_path.to_str().unwrap(),
        ])
        .status();

    match status {
        Ok(s) if s.success() => {}
        _ => {
            eprintln!("cargo:warning=Failed to link .air to .metallib, skipping metallib precompilation");
            write_empty_metallib_header(&header_path);
            return;
        }
    }

    // Generate C header with embedded metallib binary (same xxd pattern as shader header)
    let metallib_bytes = std::fs::read(&metallib_path)
        .expect("Failed to read compiled .metallib");

    let mut header = String::new();
    header.push_str("// Auto-generated by build.rs — do not edit\n");
    header.push_str("#ifndef VOXTRAL_METALLIB_SOURCE_H\n");
    header.push_str("#define VOXTRAL_METALLIB_SOURCE_H\n\n");
    header.push_str("static const unsigned char voxtral_precompiled_metallib[] = {\n");

    for (i, byte) in metallib_bytes.iter().enumerate() {
        if i % 16 == 0 {
            header.push_str("  ");
        }
        header.push_str(&format!("0x{:02x}", byte));
        if i + 1 < metallib_bytes.len() {
            header.push_str(", ");
        }
        if i % 16 == 15 {
            header.push('\n');
        }
    }
    header.push_str("\n};\n\n");
    header.push_str(&format!(
        "static const unsigned int voxtral_precompiled_metallib_len = {};\n\n",
        metallib_bytes.len()
    ));
    header.push_str("#endif // VOXTRAL_METALLIB_SOURCE_H\n");

    std::fs::write(&header_path, header)
        .expect("Failed to write voxtral_metallib_source.h");
}

/// Write an empty metallib header with zero-length array so the C code
/// can check `voxtral_precompiled_metallib_len == 0` and fall back to
/// runtime compilation gracefully.
#[cfg(feature = "voxtral")]
fn write_empty_metallib_header(header_path: &std::path::Path) {
    let header = "\
// Auto-generated by build.rs — precompilation not available\n\
#ifndef VOXTRAL_METALLIB_SOURCE_H\n\
#define VOXTRAL_METALLIB_SOURCE_H\n\n\
static const unsigned char voxtral_precompiled_metallib[] = { 0 };\n\
static const unsigned int voxtral_precompiled_metallib_len = 0;\n\n\
#endif // VOXTRAL_METALLIB_SOURCE_H\n";
    std::fs::write(header_path, header).ok();
}
