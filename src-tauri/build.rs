fn main() {
    tauri_build::build();

    #[cfg(feature = "voxtral")]
    build_voxtral();
}

#[cfg(feature = "voxtral")]
fn build_voxtral() {
    let voxtral_dir = std::path::Path::new("voxtral");
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let out_path = std::path::Path::new(&out_dir);

    // Core C source files (excluding main.c and inspect_weights.c)
    let c_sources = [
        "voxtral.c",
        "voxtral_audio.c",
        "voxtral_decoder.c",
        "voxtral_encoder.c",
        "voxtral_kernels.c",
        "voxtral_safetensors.c",
        "voxtral_tokenizer.c",
    ];

    let mut build = cc::Build::new();
    build
        .opt_level(3)
        .flag("-march=native")
        .flag("-ffast-math")
        .include(voxtral_dir);

    for src in &c_sources {
        build.file(voxtral_dir.join(src));
    }

    let target_os = std::env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
    let target_arch = std::env::var("CARGO_CFG_TARGET_ARCH").unwrap_or_default();

    if target_os == "macos" {
        // macOS: use Accelerate (BLAS) and optionally Metal on Apple Silicon
        build.flag("-DUSE_BLAS");
        println!("cargo:rustc-link-lib=framework=Accelerate");

        if target_arch == "aarch64" {
            // Apple Silicon: enable Metal GPU acceleration
            build.flag("-DUSE_METAL");

            // Generate voxtral_shaders_source.h — embeds the .metal shader as a C string
            // The voxtral_metal.m file includes this header to compile shaders at runtime
            generate_shader_header(voxtral_dir, out_path);

            // Compile Objective-C Metal bridge
            let mut metal_build = cc::Build::new();
            metal_build
                .opt_level(3)
                .flag("-ffast-math")
                .flag("-DUSE_METAL")
                .include(voxtral_dir)
                .include(out_path) // For generated voxtral_shaders_source.h
                .file(voxtral_dir.join("voxtral_metal.m"));
            metal_build.compile("voxtral_metal");

            println!("cargo:rustc-link-lib=framework=Metal");
            println!("cargo:rustc-link-lib=framework=MetalPerformanceShaders");
            println!("cargo:rustc-link-lib=framework=Foundation");
            println!("cargo:rustc-link-lib=framework=CoreGraphics");
        }
    } else if target_os == "linux" {
        // Linux: use OpenBLAS
        build.flag("-DUSE_BLAS");
        println!("cargo:rustc-link-lib=openblas");
        println!("cargo:rustc-link-lib=m");
        println!("cargo:rustc-link-lib=pthread");
    }

    build.compile("voxtral");

    // Rerun if any voxtral source changes
    println!("cargo:rerun-if-changed=voxtral/");
}

/// Generate voxtral_shaders_source.h from voxtral_shaders.metal.
/// Embeds the Metal shader source as a byte array (xxd-style), matching
/// the variable names expected by voxtral_metal.m:
///   - `voxtral_shaders_metal` (unsigned char array)
///   - `voxtral_shaders_metal_len` (unsigned int)
#[cfg(feature = "voxtral")]
fn generate_shader_header(voxtral_dir: &std::path::Path, out_dir: &std::path::Path) {
    let shader_path = voxtral_dir.join("voxtral_shaders.metal");
    let header_path = out_dir.join("voxtral_shaders_source.h");

    let shader_bytes = std::fs::read(&shader_path)
        .expect("Failed to read voxtral_shaders.metal");

    let mut header = String::new();
    header.push_str("// Auto-generated by build.rs — do not edit\n");
    header.push_str("#ifndef VOXTRAL_SHADERS_SOURCE_H\n");
    header.push_str("#define VOXTRAL_SHADERS_SOURCE_H\n\n");
    header.push_str(&format!(
        "static const unsigned char voxtral_shaders_metal[] = {{\n"
    ));

    // Write bytes in rows of 16 (xxd style)
    for (i, byte) in shader_bytes.iter().enumerate() {
        if i % 16 == 0 {
            header.push_str("  ");
        }
        header.push_str(&format!("0x{:02x}", byte));
        if i + 1 < shader_bytes.len() {
            header.push_str(", ");
        }
        if i % 16 == 15 {
            header.push('\n');
        }
    }
    header.push_str("\n};\n\n");
    header.push_str(&format!(
        "static const unsigned int voxtral_shaders_metal_len = {};\n\n",
        shader_bytes.len()
    ));
    header.push_str("#endif // VOXTRAL_SHADERS_SOURCE_H\n");

    std::fs::write(&header_path, header)
        .expect("Failed to write voxtral_shaders_source.h");

    println!("cargo:rerun-if-changed={}", shader_path.display());
}
